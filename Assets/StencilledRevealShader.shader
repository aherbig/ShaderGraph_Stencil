Shader "Custom/StencilledRevealShader"
{
	Properties
	{
		Vector1_ADE1DB20("Dissolve", Range(0, 1)) = 0.4
[Toggle] Boolean_420AB9A0("NoiseUV", Float) = 0

	}
		SubShader
	{
		Tags{ "RenderPipeline" = "LightweightPipeline"}
		Tags
		{
			"RenderPipeline" = "HDRenderPipeline"
			"RenderType" = "Opaque"
			"Queue" = "Geometry+0"
		}
		
		Stencil
		{
			Ref 1
			Comp notequal
			Pass keep
		}
		Pass
		{
			Tags{"LightMode" = "LightweightForward"}

			// Material options generated by graph

			Blend One Zero

			Cull Off

			ZTest LEqual

			ZWrite On

			HLSLPROGRAM
		// Required to compile gles 2.0 with standard srp library
		#pragma prefer_hlslcc gles
		#pragma exclude_renderers d3d11_9x
		#pragma target 2.0

		// -------------------------------------
		// Lightweight Pipeline keywords
		#pragma multi_compile _ _MAIN_LIGHT_SHADOWS
		#pragma multi_compile _ _MAIN_LIGHT_SHADOWS_CASCADE
		#pragma multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS
		#pragma multi_compile _ _ADDITIONAL_LIGHT_SHADOWS
		#pragma multi_compile _ _SHADOWS_SOFT
		#pragma multi_compile _ _MIXED_LIGHTING_SUBTRACTIVE

		// -------------------------------------
		// Unity defined keywords
		#pragma multi_compile _ DIRLIGHTMAP_COMBINED
		#pragma multi_compile _ LIGHTMAP_ON
		#pragma multi_compile_fog

		//--------------------------------------
		// GPU Instancing
		#pragma multi_compile_instancing

		#pragma vertex vert
		#pragma fragment frag

		// Defines generated by graph
		#define _AlphaClip 1

		#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl"
		#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Lighting.hlsl"
		#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
		#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/UnityInstancing.hlsl"
		#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/ShaderGraphFunctions.hlsl"

		CBUFFER_START(UnityPerMaterial)
		float Vector1_ADE1DB20;
		float Boolean_420AB9A0;
		CBUFFER_END


		struct VertexDescriptionInputs
		{
			float3 ObjectSpacePosition;
		};

		struct SurfaceDescriptionInputs
		{
			float3 TangentSpaceNormal;
			half4 uv0;
		};



	float2 unity_gradientNoise_dir(float2 p)
	{
		// Permutation and hashing used in webgl-nosie goo.gl/pX7HtC
		p = p % 289;
		float x = (34 * p.x + 1) * p.x % 289 + p.y;
		x = (34 * x + 1) * x % 289;
		x = frac(x / 41) * 2 - 1;
		return normalize(float2(x - floor(x + 0.5), abs(x) - 0.5));
	}


	float unity_gradientNoise(float2 p)
	{
		float2 ip = floor(p);
		float2 fp = frac(p);
		float d00 = dot(unity_gradientNoise_dir(ip), fp);
		float d01 = dot(unity_gradientNoise_dir(ip + float2(0, 1)), fp - float2(0, 1));
		float d10 = dot(unity_gradientNoise_dir(ip + float2(1, 0)), fp - float2(1, 0));
		float d11 = dot(unity_gradientNoise_dir(ip + float2(1, 1)), fp - float2(1, 1));
		fp = fp * fp * fp * (fp * (fp * 6 - 15) + 10);
		return lerp(lerp(d00, d01, fp.y), lerp(d10, d11, fp.y), fp.x);
	}

		void Unity_GradientNoise_float(float2 UV, float Scale, out float Out)
		{
Out = unity_gradientNoise(UV * Scale) + 0.5;
}

void Unity_Branch_float4(float Predicate, float4 True, float4 False, out float4 Out)
{
	Out = lerp(False, True, Predicate);
}


inline float unity_noise_randomValue(float2 uv)
{
	return frac(sin(dot(uv, float2(12.9898, 78.233)))*43758.5453);
}

inline float unity_noise_interpolate(float a, float b, float t)
{
	return (1.0 - t)*a + (t*b);
}


inline float unity_valueNoise(float2 uv)
{
	float2 i = floor(uv);
	float2 f = frac(uv);
	f = f * f * (3.0 - 2.0 * f);

	uv = abs(frac(uv) - 0.5);
	float2 c0 = i + float2(0.0, 0.0);
	float2 c1 = i + float2(1.0, 0.0);
	float2 c2 = i + float2(0.0, 1.0);
	float2 c3 = i + float2(1.0, 1.0);
	float r0 = unity_noise_randomValue(c0);
	float r1 = unity_noise_randomValue(c1);
	float r2 = unity_noise_randomValue(c2);
	float r3 = unity_noise_randomValue(c3);

	float bottomOfGrid = unity_noise_interpolate(r0, r1, f.x);
	float topOfGrid = unity_noise_interpolate(r2, r3, f.x);
	float t = unity_noise_interpolate(bottomOfGrid, topOfGrid, f.y);
	return t;
}
	void Unity_SimpleNoise_float(float2 UV, float Scale, out float Out)
	{
		float t = 0.0;

		float freq = pow(2.0, float(0));
		float amp = pow(0.5, float(3 - 0));
		t += unity_valueNoise(float2(UV.x*Scale / freq, UV.y*Scale / freq))*amp;

		freq = pow(2.0, float(1));
		amp = pow(0.5, float(3 - 1));
		t += unity_valueNoise(float2(UV.x*Scale / freq, UV.y*Scale / freq))*amp;

		freq = pow(2.0, float(2));
		amp = pow(0.5, float(3 - 2));
		t += unity_valueNoise(float2(UV.x*Scale / freq, UV.y*Scale / freq))*amp;

		Out = t;
	}

	void Unity_Remap_float(float In, float2 InMinMax, float2 OutMinMax, out float Out)
	{
		Out = OutMinMax.x + (In - InMinMax.x) * (OutMinMax.y - OutMinMax.x) / (InMinMax.y - InMinMax.x);
	}

	void Unity_Add_float(float A, float B, out float Out)
	{
		Out = A + B;
	}

	struct VertexDescription
	{
		float3 Position;
	};

	VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
	{
		VertexDescription description = (VertexDescription)0;
		description.Position = IN.ObjectSpacePosition;
		return description;
	}

	struct SurfaceDescription
	{
		float3 Albedo;
		float3 Normal;
		float3 Emission;
		float Metallic;
		float Smoothness;
		float Occlusion;
		float Alpha;
		float AlphaClipThreshold;
	};

	SurfaceDescription PopulateSurfaceData(SurfaceDescriptionInputs IN)
	{
		SurfaceDescription surface = (SurfaceDescription)0;
		float _Property_286219FC_Out = Vector1_ADE1DB20;
		float _Property_2F3E2FB7_Out = Boolean_420AB9A0;
		float _GradientNoise_5A06378A_Out;
		Unity_GradientNoise_float(IN.uv0.xy, 8.48, _GradientNoise_5A06378A_Out);
		float4 _UV_9D08B77E_Out = IN.uv0;
		float4 _Branch_EA861560_Out;
		Unity_Branch_float4(_Property_2F3E2FB7_Out, (_GradientNoise_5A06378A_Out.xxxx), _UV_9D08B77E_Out, _Branch_EA861560_Out);
		float _SimpleNoise_F1D99CAE_Out;
		Unity_SimpleNoise_float((_Branch_EA861560_Out.xy), 24.9, _SimpleNoise_F1D99CAE_Out);
		float _Remap_8412D6D2_Out;
		Unity_Remap_float(_SinTime.w, float2 (-1,1), float2 (-0.1,0.1), _Remap_8412D6D2_Out);
		float _Add_7DA332DC_Out;
		Unity_Add_float(_SimpleNoise_F1D99CAE_Out, _Remap_8412D6D2_Out, _Add_7DA332DC_Out);
		surface.Albedo = IsGammaSpace() ? float3(0.5, 0.5, 0.5) : SRGBToLinear(float3(0.5, 0.5, 0.5));
		surface.Normal = IN.TangentSpaceNormal;
		surface.Emission = IsGammaSpace() ? float3(0, 0, 0) : SRGBToLinear(float3(0, 0, 0));
		surface.Metallic = 0;
		surface.Smoothness = 0.5;
		surface.Occlusion = 1;
		surface.Alpha = _Property_286219FC_Out;
		surface.AlphaClipThreshold = _Add_7DA332DC_Out;
		return surface;
	}

	struct GraphVertexInput
	{
		float4 vertex : POSITION;
		float3 normal : NORMAL;
		float4 tangent : TANGENT;
		float4 texcoord0 : TEXCOORD0;
		float4 texcoord1 : TEXCOORD1;
		UNITY_VERTEX_INPUT_INSTANCE_ID
	};


	struct GraphVertexOutput
	{
		float4 clipPos                : SV_POSITION;
		DECLARE_LIGHTMAP_OR_SH(lightmapUV, vertexSH, 0);
		half4 fogFactorAndVertexLight : TEXCOORD1; // x: fogFactor, yzw: vertex light
		float4 shadowCoord            : TEXCOORD2;

		// Interpolators defined by graph
		float3 WorldSpacePosition : TEXCOORD3;
		float3 WorldSpaceNormal : TEXCOORD4;
		float3 WorldSpaceTangent : TEXCOORD5;
		float3 WorldSpaceBiTangent : TEXCOORD6;
		float3 WorldSpaceViewDirection : TEXCOORD7;
		half4 uv0 : TEXCOORD8;
		half4 uv1 : TEXCOORD9;

		UNITY_VERTEX_INPUT_INSTANCE_ID
		UNITY_VERTEX_OUTPUT_STEREO
	};

	GraphVertexOutput vert(GraphVertexInput v)
	{
		GraphVertexOutput o = (GraphVertexOutput)0;
		UNITY_SETUP_INSTANCE_ID(v);
		UNITY_TRANSFER_INSTANCE_ID(v, o);
		UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

		// Vertex transformations performed by graph
		float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
		float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
		float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
		float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
		float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
		float4 uv0 = v.texcoord0;
		float4 uv1 = v.texcoord1;
		float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0)).xyz;

		VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

		// Vertex description inputs defined by graph
		vdi.ObjectSpacePosition = ObjectSpacePosition;

		VertexDescription vd = PopulateVertexData(vdi);
		v.vertex.xyz = vd.Position;

		// Vertex shader outputs defined by graph
		o.WorldSpacePosition = WorldSpacePosition;
		o.WorldSpaceNormal = WorldSpaceNormal;
		o.WorldSpaceTangent = WorldSpaceTangent;
		o.WorldSpaceBiTangent = WorldSpaceBiTangent;
		o.WorldSpaceViewDirection = WorldSpaceViewDirection;
		o.uv0 = uv0;
		o.uv1 = uv1;

		float3 lwWNormal = TransformObjectToWorldNormal(v.normal);

		VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);

		// We either sample GI from lightmap or SH.
		// Lightmap UV and vertex SH coefficients use the same interpolator ("float2 lightmapUV" for lightmap or "half3 vertexSH" for SH)
		// see DECLARE_LIGHTMAP_OR_SH macro.
		// The following funcions initialize the correct variable with correct data
		OUTPUT_LIGHTMAP_UV(v.texcoord1, unity_LightmapST, o.lightmapUV);
		OUTPUT_SH(lwWNormal, o.vertexSH);

		half3 vertexLight = VertexLighting(vertexInput.positionWS, lwWNormal);
		half fogFactor = ComputeFogFactor(vertexInput.positionCS.z);
		o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);
		o.clipPos = vertexInput.positionCS;

	#ifdef _MAIN_LIGHT_SHADOWS
		o.shadowCoord = GetShadowCoord(vertexInput);
	#endif
		return o;
	}

	half4 frag(GraphVertexOutput IN) : SV_Target
	{
		UNITY_SETUP_INSTANCE_ID(IN);

	// Pixel transformations performed by graph
	float3 WorldSpacePosition = IN.WorldSpacePosition;
	float3 WorldSpaceNormal = IN.WorldSpaceNormal;
	float3 WorldSpaceTangent = IN.WorldSpaceTangent;
	float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
	float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
	float3x3 tangentSpaceTransform = float3x3(WorldSpaceTangent,WorldSpaceBiTangent,WorldSpaceNormal);
	float4 uv0 = IN.uv0;
	float4 uv1 = IN.uv1;
	float3 TangentSpaceNormal = mul(WorldSpaceNormal,(float3x3)tangentSpaceTransform).xyz;

	SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

	// Surface description inputs defined by graph
	surfaceInput.TangentSpaceNormal = TangentSpaceNormal;
	surfaceInput.uv0 = uv0;

	SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

	float3 Albedo = float3(0.5, 0.5, 0.5);
	float3 Specular = float3(0, 0, 0);
	float Metallic = 1;
	float3 Normal = float3(0, 0, 1);
	float3 Emission = 0;
	float Smoothness = 0.5;
	float Occlusion = 1;
	float Alpha = 1;
	float AlphaClipThreshold = 0;

	// Surface description remap performed by graph
	Albedo = surf.Albedo;
	Normal = surf.Normal;
	Emission = surf.Emission;
	Metallic = surf.Metallic;
	Smoothness = surf.Smoothness;
	Occlusion = surf.Occlusion;
	Alpha = surf.Alpha;
	AlphaClipThreshold = surf.AlphaClipThreshold;

	InputData inputData;
	inputData.positionWS = WorldSpacePosition;

#ifdef _NORMALMAP
		inputData.normalWS = normalize(TransformTangentToWorld(Normal, half3x3(WorldSpaceTangent, WorldSpaceBiTangent, WorldSpaceNormal)));
#else
	#if !SHADER_HINT_NICE_QUALITY
		inputData.normalWS = WorldSpaceNormal;
	#else
		inputData.normalWS = normalize(WorldSpaceNormal);
	#endif
#endif

#if !SHADER_HINT_NICE_QUALITY
		// viewDirection should be normalized here, but we avoid doing it as it's close enough and we save some ALU.
		inputData.viewDirectionWS = WorldSpaceViewDirection;
#else
		inputData.viewDirectionWS = normalize(WorldSpaceViewDirection);
#endif

		inputData.shadowCoord = IN.shadowCoord;

		inputData.fogCoord = IN.fogFactorAndVertexLight.x;
		inputData.vertexLighting = IN.fogFactorAndVertexLight.yzw;
		inputData.bakedGI = SAMPLE_GI(IN.lightmapUV, IN.vertexSH, inputData.normalWS);

		half4 color = LightweightFragmentPBR(
			inputData,
			Albedo,
			Metallic,
			Specular,
			Smoothness,
			Occlusion,
			Emission,
			Alpha);

		// Computes fog factor per-vertex
		color.rgb = MixFog(color.rgb, IN.fogFactorAndVertexLight.x);

#if _AlphaClip
		clip(Alpha - AlphaClipThreshold);
#endif
		return color;
	}

	ENDHLSL
}
Pass
{
	Name "ShadowCaster"
	Tags{"LightMode" = "ShadowCaster"}

	ZWrite On ZTest LEqual

		// Material options generated by graph
		Cull Off

		HLSLPROGRAM
		// Required to compile gles 2.0 with standard srp library
		#pragma prefer_hlslcc gles
		#pragma exclude_renderers d3d11_9x
		#pragma target 2.0

		//--------------------------------------
		// GPU Instancing
		#pragma multi_compile_instancing

		#pragma vertex ShadowPassVertex
		#pragma fragment ShadowPassFragment

		// Defines generated by graph
		#define _AlphaClip 1

		#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl"
		#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Lighting.hlsl"
		#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/ShaderGraphFunctions.hlsl"
		#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"

		CBUFFER_START(UnityPerMaterial)
		float Vector1_ADE1DB20;
		float Boolean_420AB9A0;
		CBUFFER_END


		struct VertexDescriptionInputs
		{
			float3 ObjectSpacePosition;
		};

		struct SurfaceDescriptionInputs
		{
			float3 TangentSpaceNormal;
			half4 uv0;
		};



	float2 unity_gradientNoise_dir(float2 p)
	{
		// Permutation and hashing used in webgl-nosie goo.gl/pX7HtC
		p = p % 289;
		float x = (34 * p.x + 1) * p.x % 289 + p.y;
		x = (34 * x + 1) * x % 289;
		x = frac(x / 41) * 2 - 1;
		return normalize(float2(x - floor(x + 0.5), abs(x) - 0.5));
	}


	float unity_gradientNoise(float2 p)
	{
		float2 ip = floor(p);
		float2 fp = frac(p);
		float d00 = dot(unity_gradientNoise_dir(ip), fp);
		float d01 = dot(unity_gradientNoise_dir(ip + float2(0, 1)), fp - float2(0, 1));
		float d10 = dot(unity_gradientNoise_dir(ip + float2(1, 0)), fp - float2(1, 0));
		float d11 = dot(unity_gradientNoise_dir(ip + float2(1, 1)), fp - float2(1, 1));
		fp = fp * fp * fp * (fp * (fp * 6 - 15) + 10);
		return lerp(lerp(d00, d01, fp.y), lerp(d10, d11, fp.y), fp.x);
	}

		void Unity_GradientNoise_float(float2 UV, float Scale, out float Out)
		{
Out = unity_gradientNoise(UV * Scale) + 0.5;
}

void Unity_Branch_float4(float Predicate, float4 True, float4 False, out float4 Out)
{
	Out = lerp(False, True, Predicate);
}


inline float unity_noise_randomValue(float2 uv)
{
	return frac(sin(dot(uv, float2(12.9898, 78.233)))*43758.5453);
}

inline float unity_noise_interpolate(float a, float b, float t)
{
	return (1.0 - t)*a + (t*b);
}


inline float unity_valueNoise(float2 uv)
{
	float2 i = floor(uv);
	float2 f = frac(uv);
	f = f * f * (3.0 - 2.0 * f);

	uv = abs(frac(uv) - 0.5);
	float2 c0 = i + float2(0.0, 0.0);
	float2 c1 = i + float2(1.0, 0.0);
	float2 c2 = i + float2(0.0, 1.0);
	float2 c3 = i + float2(1.0, 1.0);
	float r0 = unity_noise_randomValue(c0);
	float r1 = unity_noise_randomValue(c1);
	float r2 = unity_noise_randomValue(c2);
	float r3 = unity_noise_randomValue(c3);

	float bottomOfGrid = unity_noise_interpolate(r0, r1, f.x);
	float topOfGrid = unity_noise_interpolate(r2, r3, f.x);
	float t = unity_noise_interpolate(bottomOfGrid, topOfGrid, f.y);
	return t;
}
	void Unity_SimpleNoise_float(float2 UV, float Scale, out float Out)
	{
		float t = 0.0;

		float freq = pow(2.0, float(0));
		float amp = pow(0.5, float(3 - 0));
		t += unity_valueNoise(float2(UV.x*Scale / freq, UV.y*Scale / freq))*amp;

		freq = pow(2.0, float(1));
		amp = pow(0.5, float(3 - 1));
		t += unity_valueNoise(float2(UV.x*Scale / freq, UV.y*Scale / freq))*amp;

		freq = pow(2.0, float(2));
		amp = pow(0.5, float(3 - 2));
		t += unity_valueNoise(float2(UV.x*Scale / freq, UV.y*Scale / freq))*amp;

		Out = t;
	}

	void Unity_Remap_float(float In, float2 InMinMax, float2 OutMinMax, out float Out)
	{
		Out = OutMinMax.x + (In - InMinMax.x) * (OutMinMax.y - OutMinMax.x) / (InMinMax.y - InMinMax.x);
	}

	void Unity_Add_float(float A, float B, out float Out)
	{
		Out = A + B;
	}

	struct VertexDescription
	{
		float3 Position;
	};

	VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
	{
		VertexDescription description = (VertexDescription)0;
		description.Position = IN.ObjectSpacePosition;
		return description;
	}

	struct SurfaceDescription
	{
		float3 Albedo;
		float3 Emission;
		float Alpha;
		float AlphaClipThreshold;
	};

	SurfaceDescription PopulateSurfaceData(SurfaceDescriptionInputs IN)
	{
		SurfaceDescription surface = (SurfaceDescription)0;
		float _Property_286219FC_Out = Vector1_ADE1DB20;
		float _Property_2F3E2FB7_Out = Boolean_420AB9A0;
		float _GradientNoise_5A06378A_Out;
		Unity_GradientNoise_float(IN.uv0.xy, 8.48, _GradientNoise_5A06378A_Out);
		float4 _UV_9D08B77E_Out = IN.uv0;
		float4 _Branch_EA861560_Out;
		Unity_Branch_float4(_Property_2F3E2FB7_Out, (_GradientNoise_5A06378A_Out.xxxx), _UV_9D08B77E_Out, _Branch_EA861560_Out);
		float _SimpleNoise_F1D99CAE_Out;
		Unity_SimpleNoise_float((_Branch_EA861560_Out.xy), 24.9, _SimpleNoise_F1D99CAE_Out);
		float _Remap_8412D6D2_Out;
		Unity_Remap_float(_SinTime.w, float2 (-1,1), float2 (-0.1,0.1), _Remap_8412D6D2_Out);
		float _Add_7DA332DC_Out;
		Unity_Add_float(_SimpleNoise_F1D99CAE_Out, _Remap_8412D6D2_Out, _Add_7DA332DC_Out);
		surface.Albedo = IsGammaSpace() ? float3(0.5, 0.5, 0.5) : SRGBToLinear(float3(0.5, 0.5, 0.5));
		surface.Emission = IsGammaSpace() ? float3(0, 0, 0) : SRGBToLinear(float3(0, 0, 0));
		surface.Alpha = _Property_286219FC_Out;
		surface.AlphaClipThreshold = _Add_7DA332DC_Out;
		return surface;
	}

	struct GraphVertexInput
	{
		float4 vertex : POSITION;
		float3 normal : NORMAL;
		float4 tangent : TANGENT;
		float4 texcoord0 : TEXCOORD0;
		float4 texcoord1 : TEXCOORD1;
		UNITY_VERTEX_INPUT_INSTANCE_ID
	};


	struct VertexOutput
	{
		float2 uv           : TEXCOORD0;
		float4 clipPos      : SV_POSITION;
		// Interpolators defined by graph
		float3 WorldSpacePosition : TEXCOORD3;
		float3 WorldSpaceNormal : TEXCOORD4;
		float3 WorldSpaceTangent : TEXCOORD5;
		float3 WorldSpaceBiTangent : TEXCOORD6;
		float3 WorldSpaceViewDirection : TEXCOORD7;
		half4 uv0 : TEXCOORD8;
		half4 uv1 : TEXCOORD9;

		UNITY_VERTEX_INPUT_INSTANCE_ID
	};

	// x: global clip space bias, y: normal world space bias
	float4 _ShadowBias;
	float3 _LightDirection;

	VertexOutput ShadowPassVertex(GraphVertexInput v)
	{
		VertexOutput o;
		UNITY_SETUP_INSTANCE_ID(v);
		UNITY_TRANSFER_INSTANCE_ID(v, o);

		// Vertex transformations performed by graph
		float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
		float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
		float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
		float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
		float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
		float4 uv0 = v.texcoord0;
		float4 uv1 = v.texcoord1;
		float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0)).xyz;

		VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

		// Vertex description inputs defined by graph
		vdi.ObjectSpacePosition = ObjectSpacePosition;

		VertexDescription vd = PopulateVertexData(vdi);
		v.vertex.xyz = vd.Position;

		// Vertex shader outputs defined by graph
		o.WorldSpacePosition = WorldSpacePosition;
		o.WorldSpaceNormal = WorldSpaceNormal;
		o.WorldSpaceTangent = WorldSpaceTangent;
		o.WorldSpaceBiTangent = WorldSpaceBiTangent;
		o.WorldSpaceViewDirection = WorldSpaceViewDirection;
		o.uv0 = uv0;
		o.uv1 = uv1;


		float3 positionWS = TransformObjectToWorld(v.vertex.xyz);
		float3 normalWS = TransformObjectToWorldDir(v.normal);

		float invNdotL = 1.0 - saturate(dot(_LightDirection, normalWS));
		float scale = invNdotL * _ShadowBias.y;

		// normal bias is negative since we want to apply an inset normal offset
		positionWS = normalWS * scale.xxx + positionWS;
		float4 clipPos = TransformWorldToHClip(positionWS);

		// _ShadowBias.x sign depens on if platform has reversed z buffer
		clipPos.z += _ShadowBias.x;

	#if UNITY_REVERSED_Z
		clipPos.z = min(clipPos.z, clipPos.w * UNITY_NEAR_CLIP_VALUE);
	#else
		clipPos.z = max(clipPos.z, clipPos.w * UNITY_NEAR_CLIP_VALUE);
	#endif
		o.clipPos = clipPos;

		return o;
	}

	half4 ShadowPassFragment(VertexOutput IN) : SV_TARGET
	{
		UNITY_SETUP_INSTANCE_ID(IN);

	// Pixel transformations performed by graph
	float3 WorldSpacePosition = IN.WorldSpacePosition;
	float3 WorldSpaceNormal = IN.WorldSpaceNormal;
	float3 WorldSpaceTangent = IN.WorldSpaceTangent;
	float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
	float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
	float3x3 tangentSpaceTransform = float3x3(WorldSpaceTangent,WorldSpaceBiTangent,WorldSpaceNormal);
	float4 uv0 = IN.uv0;
	float4 uv1 = IN.uv1;
	float3 TangentSpaceNormal = mul(WorldSpaceNormal,(float3x3)tangentSpaceTransform).xyz;

	SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

	// Surface description inputs defined by graph
	surfaceInput.TangentSpaceNormal = TangentSpaceNormal;
	surfaceInput.uv0 = uv0;

	SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

	float3 Albedo = float3(0.5, 0.5, 0.5);
	float3 Emission = 0;
	float Alpha = 1;
	float AlphaClipThreshold = 0;

	// Surface description remap performed by graph
	Albedo = surf.Albedo;
	Emission = surf.Emission;
	Alpha = surf.Alpha;
	AlphaClipThreshold = surf.AlphaClipThreshold;

#if _AlphaClip
	   clip(Alpha - AlphaClipThreshold);
#endif
		return 0;
	}

	ENDHLSL
}

Pass
{
	Name "DepthOnly"
	Tags{"LightMode" = "DepthOnly"}

	ZWrite On
	ColorMask 0

		// Material options generated by graph
		Cull Off

		HLSLPROGRAM
		// Required to compile gles 2.0 with standard srp library
		#pragma prefer_hlslcc gles
		#pragma exclude_renderers d3d11_9x
		#pragma target 2.0

		//--------------------------------------
		// GPU Instancing
		#pragma multi_compile_instancing

		#pragma vertex vert
		#pragma fragment frag

		// Defines generated by graph
		#define _AlphaClip 1

		#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl"
		#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Lighting.hlsl"
		#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/ShaderGraphFunctions.hlsl"
		#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"

		CBUFFER_START(UnityPerMaterial)
		float Vector1_ADE1DB20;
		float Boolean_420AB9A0;
		CBUFFER_END


		struct VertexDescriptionInputs
		{
			float3 ObjectSpacePosition;
		};

		struct SurfaceDescriptionInputs
		{
			float3 TangentSpaceNormal;
			half4 uv0;
		};



	float2 unity_gradientNoise_dir(float2 p)
	{
		// Permutation and hashing used in webgl-nosie goo.gl/pX7HtC
		p = p % 289;
		float x = (34 * p.x + 1) * p.x % 289 + p.y;
		x = (34 * x + 1) * x % 289;
		x = frac(x / 41) * 2 - 1;
		return normalize(float2(x - floor(x + 0.5), abs(x) - 0.5));
	}


	float unity_gradientNoise(float2 p)
	{
		float2 ip = floor(p);
		float2 fp = frac(p);
		float d00 = dot(unity_gradientNoise_dir(ip), fp);
		float d01 = dot(unity_gradientNoise_dir(ip + float2(0, 1)), fp - float2(0, 1));
		float d10 = dot(unity_gradientNoise_dir(ip + float2(1, 0)), fp - float2(1, 0));
		float d11 = dot(unity_gradientNoise_dir(ip + float2(1, 1)), fp - float2(1, 1));
		fp = fp * fp * fp * (fp * (fp * 6 - 15) + 10);
		return lerp(lerp(d00, d01, fp.y), lerp(d10, d11, fp.y), fp.x);
	}

		void Unity_GradientNoise_float(float2 UV, float Scale, out float Out)
		{
Out = unity_gradientNoise(UV * Scale) + 0.5;
}

void Unity_Branch_float4(float Predicate, float4 True, float4 False, out float4 Out)
{
	Out = lerp(False, True, Predicate);
}


inline float unity_noise_randomValue(float2 uv)
{
	return frac(sin(dot(uv, float2(12.9898, 78.233)))*43758.5453);
}

inline float unity_noise_interpolate(float a, float b, float t)
{
	return (1.0 - t)*a + (t*b);
}


inline float unity_valueNoise(float2 uv)
{
	float2 i = floor(uv);
	float2 f = frac(uv);
	f = f * f * (3.0 - 2.0 * f);

	uv = abs(frac(uv) - 0.5);
	float2 c0 = i + float2(0.0, 0.0);
	float2 c1 = i + float2(1.0, 0.0);
	float2 c2 = i + float2(0.0, 1.0);
	float2 c3 = i + float2(1.0, 1.0);
	float r0 = unity_noise_randomValue(c0);
	float r1 = unity_noise_randomValue(c1);
	float r2 = unity_noise_randomValue(c2);
	float r3 = unity_noise_randomValue(c3);

	float bottomOfGrid = unity_noise_interpolate(r0, r1, f.x);
	float topOfGrid = unity_noise_interpolate(r2, r3, f.x);
	float t = unity_noise_interpolate(bottomOfGrid, topOfGrid, f.y);
	return t;
}
	void Unity_SimpleNoise_float(float2 UV, float Scale, out float Out)
	{
		float t = 0.0;

		float freq = pow(2.0, float(0));
		float amp = pow(0.5, float(3 - 0));
		t += unity_valueNoise(float2(UV.x*Scale / freq, UV.y*Scale / freq))*amp;

		freq = pow(2.0, float(1));
		amp = pow(0.5, float(3 - 1));
		t += unity_valueNoise(float2(UV.x*Scale / freq, UV.y*Scale / freq))*amp;

		freq = pow(2.0, float(2));
		amp = pow(0.5, float(3 - 2));
		t += unity_valueNoise(float2(UV.x*Scale / freq, UV.y*Scale / freq))*amp;

		Out = t;
	}

	void Unity_Remap_float(float In, float2 InMinMax, float2 OutMinMax, out float Out)
	{
		Out = OutMinMax.x + (In - InMinMax.x) * (OutMinMax.y - OutMinMax.x) / (InMinMax.y - InMinMax.x);
	}

	void Unity_Add_float(float A, float B, out float Out)
	{
		Out = A + B;
	}

	struct VertexDescription
	{
		float3 Position;
	};

	VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
	{
		VertexDescription description = (VertexDescription)0;
		description.Position = IN.ObjectSpacePosition;
		return description;
	}

	struct SurfaceDescription
	{
		float3 Albedo;
		float3 Emission;
		float Alpha;
		float AlphaClipThreshold;
	};

	SurfaceDescription PopulateSurfaceData(SurfaceDescriptionInputs IN)
	{
		SurfaceDescription surface = (SurfaceDescription)0;
		float _Property_286219FC_Out = Vector1_ADE1DB20;
		float _Property_2F3E2FB7_Out = Boolean_420AB9A0;
		float _GradientNoise_5A06378A_Out;
		Unity_GradientNoise_float(IN.uv0.xy, 8.48, _GradientNoise_5A06378A_Out);
		float4 _UV_9D08B77E_Out = IN.uv0;
		float4 _Branch_EA861560_Out;
		Unity_Branch_float4(_Property_2F3E2FB7_Out, (_GradientNoise_5A06378A_Out.xxxx), _UV_9D08B77E_Out, _Branch_EA861560_Out);
		float _SimpleNoise_F1D99CAE_Out;
		Unity_SimpleNoise_float((_Branch_EA861560_Out.xy), 24.9, _SimpleNoise_F1D99CAE_Out);
		float _Remap_8412D6D2_Out;
		Unity_Remap_float(_SinTime.w, float2 (-1,1), float2 (-0.1,0.1), _Remap_8412D6D2_Out);
		float _Add_7DA332DC_Out;
		Unity_Add_float(_SimpleNoise_F1D99CAE_Out, _Remap_8412D6D2_Out, _Add_7DA332DC_Out);
		surface.Albedo = IsGammaSpace() ? float3(0.5, 0.5, 0.5) : SRGBToLinear(float3(0.5, 0.5, 0.5));
		surface.Emission = IsGammaSpace() ? float3(0, 0, 0) : SRGBToLinear(float3(0, 0, 0));
		surface.Alpha = _Property_286219FC_Out;
		surface.AlphaClipThreshold = _Add_7DA332DC_Out;
		return surface;
	}

	struct GraphVertexInput
	{
		float4 vertex : POSITION;
		float3 normal : NORMAL;
		float4 tangent : TANGENT;
		float4 texcoord0 : TEXCOORD0;
		float4 texcoord1 : TEXCOORD1;
		UNITY_VERTEX_INPUT_INSTANCE_ID
	};


	struct VertexOutput
	{
		float2 uv           : TEXCOORD0;
		float4 clipPos      : SV_POSITION;
		// Interpolators defined by graph
		float3 WorldSpacePosition : TEXCOORD3;
		float3 WorldSpaceNormal : TEXCOORD4;
		float3 WorldSpaceTangent : TEXCOORD5;
		float3 WorldSpaceBiTangent : TEXCOORD6;
		float3 WorldSpaceViewDirection : TEXCOORD7;
		half4 uv0 : TEXCOORD8;
		half4 uv1 : TEXCOORD9;

		UNITY_VERTEX_INPUT_INSTANCE_ID
		UNITY_VERTEX_OUTPUT_STEREO
	};

	VertexOutput vert(GraphVertexInput v)
	{
		VertexOutput o = (VertexOutput)0;
		UNITY_SETUP_INSTANCE_ID(v);
		UNITY_TRANSFER_INSTANCE_ID(v, o);
		UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

		// Vertex transformations performed by graph
		float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
		float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
		float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
		float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
		float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
		float4 uv0 = v.texcoord0;
		float4 uv1 = v.texcoord1;
		float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0)).xyz;

		VertexDescriptionInputs vdi = (VertexDescriptionInputs)0;

		// Vertex description inputs defined by graph
		vdi.ObjectSpacePosition = ObjectSpacePosition;

		VertexDescription vd = PopulateVertexData(vdi);
		v.vertex.xyz = vd.Position;

		// Vertex shader outputs defined by graph
		o.WorldSpacePosition = WorldSpacePosition;
		o.WorldSpaceNormal = WorldSpaceNormal;
		o.WorldSpaceTangent = WorldSpaceTangent;
		o.WorldSpaceBiTangent = WorldSpaceBiTangent;
		o.WorldSpaceViewDirection = WorldSpaceViewDirection;
		o.uv0 = uv0;
		o.uv1 = uv1;

		o.clipPos = TransformObjectToHClip(v.vertex.xyz);
		return o;
	}

	half4 frag(VertexOutput IN) : SV_TARGET
	{
		UNITY_SETUP_INSTANCE_ID(IN);

	// Pixel transformations performed by graph
	float3 WorldSpacePosition = IN.WorldSpacePosition;
	float3 WorldSpaceNormal = IN.WorldSpaceNormal;
	float3 WorldSpaceTangent = IN.WorldSpaceTangent;
	float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
	float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
	float3x3 tangentSpaceTransform = float3x3(WorldSpaceTangent,WorldSpaceBiTangent,WorldSpaceNormal);
	float4 uv0 = IN.uv0;
	float4 uv1 = IN.uv1;
	float3 TangentSpaceNormal = mul(WorldSpaceNormal,(float3x3)tangentSpaceTransform).xyz;

	SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

	// Surface description inputs defined by graph
	surfaceInput.TangentSpaceNormal = TangentSpaceNormal;
	surfaceInput.uv0 = uv0;

	SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

	float3 Albedo = float3(0.5, 0.5, 0.5);
	float3 Emission = 0;
	float Alpha = 1;
	float AlphaClipThreshold = 0;

	// Surface description remap performed by graph
	Albedo = surf.Albedo;
	Emission = surf.Emission;
	Alpha = surf.Alpha;
	AlphaClipThreshold = surf.AlphaClipThreshold;

#if _AlphaClip
	   clip(Alpha - AlphaClipThreshold);
#endif
		return 0;
	}
	ENDHLSL
}

// This pass it not used during regular rendering, only for lightmap baking.
Pass
{
	Name "Meta"
	Tags{"LightMode" = "Meta"}

	Cull Off

	HLSLPROGRAM
		// Required to compile gles 2.0 with standard srp library
		#pragma prefer_hlslcc gles
		#pragma exclude_renderers d3d11_9x
		#pragma target 2.0

		#pragma vertex vert
		#pragma fragment frag

		float4 _MainTex_ST;

	// Defines generated by graph
	#define _AlphaClip 1

	#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/Core.hlsl"
	#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/MetaInput.hlsl"
	#include "Packages/com.unity.render-pipelines.lightweight/ShaderLibrary/ShaderGraphFunctions.hlsl"
	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"

	#pragma shader_feature _ _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A

		CBUFFER_START(UnityPerMaterial)
	float Vector1_ADE1DB20;
	float Boolean_420AB9A0;
	CBUFFER_END


	struct VertexDescriptionInputs
	{
		float3 ObjectSpacePosition;
	};

	struct SurfaceDescriptionInputs
	{
		float3 TangentSpaceNormal;
		half4 uv0;
	};



float2 unity_gradientNoise_dir(float2 p)
{
	// Permutation and hashing used in webgl-nosie goo.gl/pX7HtC
	p = p % 289;
	float x = (34 * p.x + 1) * p.x % 289 + p.y;
	x = (34 * x + 1) * x % 289;
	x = frac(x / 41) * 2 - 1;
	return normalize(float2(x - floor(x + 0.5), abs(x) - 0.5));
}


float unity_gradientNoise(float2 p)
{
	float2 ip = floor(p);
	float2 fp = frac(p);
	float d00 = dot(unity_gradientNoise_dir(ip), fp);
	float d01 = dot(unity_gradientNoise_dir(ip + float2(0, 1)), fp - float2(0, 1));
	float d10 = dot(unity_gradientNoise_dir(ip + float2(1, 0)), fp - float2(1, 0));
	float d11 = dot(unity_gradientNoise_dir(ip + float2(1, 1)), fp - float2(1, 1));
	fp = fp * fp * fp * (fp * (fp * 6 - 15) + 10);
	return lerp(lerp(d00, d01, fp.y), lerp(d10, d11, fp.y), fp.x);
}

	void Unity_GradientNoise_float(float2 UV, float Scale, out float Out)
	{
Out = unity_gradientNoise(UV * Scale) + 0.5;
}

void Unity_Branch_float4(float Predicate, float4 True, float4 False, out float4 Out)
{
	Out = lerp(False, True, Predicate);
}


inline float unity_noise_randomValue(float2 uv)
{
	return frac(sin(dot(uv, float2(12.9898, 78.233)))*43758.5453);
}

inline float unity_noise_interpolate(float a, float b, float t)
{
	return (1.0 - t)*a + (t*b);
}


inline float unity_valueNoise(float2 uv)
{
	float2 i = floor(uv);
	float2 f = frac(uv);
	f = f * f * (3.0 - 2.0 * f);

	uv = abs(frac(uv) - 0.5);
	float2 c0 = i + float2(0.0, 0.0);
	float2 c1 = i + float2(1.0, 0.0);
	float2 c2 = i + float2(0.0, 1.0);
	float2 c3 = i + float2(1.0, 1.0);
	float r0 = unity_noise_randomValue(c0);
	float r1 = unity_noise_randomValue(c1);
	float r2 = unity_noise_randomValue(c2);
	float r3 = unity_noise_randomValue(c3);

	float bottomOfGrid = unity_noise_interpolate(r0, r1, f.x);
	float topOfGrid = unity_noise_interpolate(r2, r3, f.x);
	float t = unity_noise_interpolate(bottomOfGrid, topOfGrid, f.y);
	return t;
}
	void Unity_SimpleNoise_float(float2 UV, float Scale, out float Out)
	{
		float t = 0.0;

		float freq = pow(2.0, float(0));
		float amp = pow(0.5, float(3 - 0));
		t += unity_valueNoise(float2(UV.x*Scale / freq, UV.y*Scale / freq))*amp;

		freq = pow(2.0, float(1));
		amp = pow(0.5, float(3 - 1));
		t += unity_valueNoise(float2(UV.x*Scale / freq, UV.y*Scale / freq))*amp;

		freq = pow(2.0, float(2));
		amp = pow(0.5, float(3 - 2));
		t += unity_valueNoise(float2(UV.x*Scale / freq, UV.y*Scale / freq))*amp;

		Out = t;
	}

	void Unity_Remap_float(float In, float2 InMinMax, float2 OutMinMax, out float Out)
	{
		Out = OutMinMax.x + (In - InMinMax.x) * (OutMinMax.y - OutMinMax.x) / (InMinMax.y - InMinMax.x);
	}

	void Unity_Add_float(float A, float B, out float Out)
	{
		Out = A + B;
	}

	struct VertexDescription
	{
		float3 Position;
	};

	VertexDescription PopulateVertexData(VertexDescriptionInputs IN)
	{
		VertexDescription description = (VertexDescription)0;
		description.Position = IN.ObjectSpacePosition;
		return description;
	}

	struct SurfaceDescription
	{
		float3 Albedo;
		float3 Emission;
		float Alpha;
		float AlphaClipThreshold;
	};

	SurfaceDescription PopulateSurfaceData(SurfaceDescriptionInputs IN)
	{
		SurfaceDescription surface = (SurfaceDescription)0;
		float _Property_286219FC_Out = Vector1_ADE1DB20;
		float _Property_2F3E2FB7_Out = Boolean_420AB9A0;
		float _GradientNoise_5A06378A_Out;
		Unity_GradientNoise_float(IN.uv0.xy, 8.48, _GradientNoise_5A06378A_Out);
		float4 _UV_9D08B77E_Out = IN.uv0;
		float4 _Branch_EA861560_Out;
		Unity_Branch_float4(_Property_2F3E2FB7_Out, (_GradientNoise_5A06378A_Out.xxxx), _UV_9D08B77E_Out, _Branch_EA861560_Out);
		float _SimpleNoise_F1D99CAE_Out;
		Unity_SimpleNoise_float((_Branch_EA861560_Out.xy), 24.9, _SimpleNoise_F1D99CAE_Out);
		float _Remap_8412D6D2_Out;
		Unity_Remap_float(_SinTime.w, float2 (-1,1), float2 (-0.1,0.1), _Remap_8412D6D2_Out);
		float _Add_7DA332DC_Out;
		Unity_Add_float(_SimpleNoise_F1D99CAE_Out, _Remap_8412D6D2_Out, _Add_7DA332DC_Out);
		surface.Albedo = IsGammaSpace() ? float3(0.5, 0.5, 0.5) : SRGBToLinear(float3(0.5, 0.5, 0.5));
		surface.Emission = IsGammaSpace() ? float3(0, 0, 0) : SRGBToLinear(float3(0, 0, 0));
		surface.Alpha = _Property_286219FC_Out;
		surface.AlphaClipThreshold = _Add_7DA332DC_Out;
		return surface;
	}

	struct GraphVertexInput
	{
		float4 vertex : POSITION;
		float3 normal : NORMAL;
		float4 tangent : TANGENT;
		float4 texcoord0 : TEXCOORD0;
		float4 texcoord1 : TEXCOORD1;
		UNITY_VERTEX_INPUT_INSTANCE_ID
	};


	struct VertexOutput
	{
		float2 uv           : TEXCOORD0;
		float4 clipPos      : SV_POSITION;
		// Interpolators defined by graph
		float3 WorldSpacePosition : TEXCOORD3;
		float3 WorldSpaceNormal : TEXCOORD4;
		float3 WorldSpaceTangent : TEXCOORD5;
		float3 WorldSpaceBiTangent : TEXCOORD6;
		float3 WorldSpaceViewDirection : TEXCOORD7;
		half4 uv0 : TEXCOORD8;
		half4 uv1 : TEXCOORD9;

		UNITY_VERTEX_INPUT_INSTANCE_ID
		UNITY_VERTEX_OUTPUT_STEREO
	};

	VertexOutput vert(GraphVertexInput v)
	{
		VertexOutput o = (VertexOutput)0;
		UNITY_SETUP_INSTANCE_ID(v);
		UNITY_TRANSFER_INSTANCE_ID(v, o);
		UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);

		// Vertex transformations performed by graph
		float3 WorldSpacePosition = mul(UNITY_MATRIX_M,v.vertex).xyz;
		float3 WorldSpaceNormal = normalize(mul(v.normal,(float3x3)UNITY_MATRIX_I_M));
		float3 WorldSpaceTangent = normalize(mul((float3x3)UNITY_MATRIX_M,v.tangent.xyz));
		float3 WorldSpaceBiTangent = cross(WorldSpaceNormal, WorldSpaceTangent.xyz) * v.tangent.w;
		float3 WorldSpaceViewDirection = _WorldSpaceCameraPos.xyz - mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1.0)).xyz;
		float4 uv0 = v.texcoord0;
		float4 uv1 = v.texcoord1;
		float3 ObjectSpacePosition = mul(UNITY_MATRIX_I_M,float4(WorldSpacePosition,1.0)).xyz;


		// Vertex shader outputs defined by graph
		o.WorldSpacePosition = WorldSpacePosition;
		o.WorldSpaceNormal = WorldSpaceNormal;
		o.WorldSpaceTangent = WorldSpaceTangent;
		o.WorldSpaceBiTangent = WorldSpaceBiTangent;
		o.WorldSpaceViewDirection = WorldSpaceViewDirection;
		o.uv0 = uv0;
		o.uv1 = uv1;

		o.clipPos = MetaVertexPosition(v.vertex, uv1, uv1, unity_LightmapST);
		return o;
	}

	half4 frag(VertexOutput IN) : SV_TARGET
	{
		UNITY_SETUP_INSTANCE_ID(IN);

	// Pixel transformations performed by graph
	float3 WorldSpacePosition = IN.WorldSpacePosition;
	float3 WorldSpaceNormal = IN.WorldSpaceNormal;
	float3 WorldSpaceTangent = IN.WorldSpaceTangent;
	float3 WorldSpaceBiTangent = IN.WorldSpaceBiTangent;
	float3 WorldSpaceViewDirection = IN.WorldSpaceViewDirection;
	float3x3 tangentSpaceTransform = float3x3(WorldSpaceTangent,WorldSpaceBiTangent,WorldSpaceNormal);
	float4 uv0 = IN.uv0;
	float4 uv1 = IN.uv1;
	float3 TangentSpaceNormal = mul(WorldSpaceNormal,(float3x3)tangentSpaceTransform).xyz;

	SurfaceDescriptionInputs surfaceInput = (SurfaceDescriptionInputs)0;

	// Surface description inputs defined by graph
	surfaceInput.TangentSpaceNormal = TangentSpaceNormal;
	surfaceInput.uv0 = uv0;

	SurfaceDescription surf = PopulateSurfaceData(surfaceInput);

	float3 Albedo = float3(0.5, 0.5, 0.5);
	float3 Emission = 0;
	float Alpha = 1;
	float AlphaClipThreshold = 0;

	// Surface description remap performed by graph
	Albedo = surf.Albedo;
	Emission = surf.Emission;
	Alpha = surf.Alpha;
	AlphaClipThreshold = surf.AlphaClipThreshold;

#if _AlphaClip
	   clip(Alpha - AlphaClipThreshold);
#endif

		MetaInput metaInput = (MetaInput)0;
		metaInput.Albedo = Albedo;
		metaInput.Emission = Emission;

		return MetaFragment(metaInput);
	}
	ENDHLSL
}
	}
		CustomEditor "UnityEditor.ShaderGraph.PBRMasterGUI"
		FallBack "Hidden/InternalErrorShader"
}
